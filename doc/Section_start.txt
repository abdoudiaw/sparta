"Previous Section"_Section_intro.html - "SPARTA WWW Site"_sws - "SPARTA Documentation"_sd - "SPARTA Commands"_sc - "Next Section"_Section_commands.html :c

:link(sws,http://sparta.sandia.gov)
:link(sd,Manual.html)
:link(sc,Section_commands.html#comm)

:line

2. Getting Started :h3

This section describes how to build and run SPARTA, for both new and
experienced users.

2.1 "What's in the SPARTA distribution"_#start_1
2.2 "Making SPARTA"_#start_2
2.3 "Building SPARTA as a library"_#start_3
2.4 "Running SPARTA"_#start_4
2.5 "Command-line options"_#start_5
2.6 "Screen output"_#start_6 :all(b)

:line

2.1 What's in the SPARTA distribution :h4,link(start_1)

When you download SPARTA you will need to unzip and untar the
downloaded file with the following commands:

gunzip sparta*.tar.gz 
tar xvf sparta*.tar :pre

This will create a SPARTA directory containing two files and several
sub-directories:
    
README: text file
LICENSE: the GNU General Public License (GPL)
bench: benchmark problems
doc: documentation
examples: simple test problems
python: Python wrapper
src: source files
tools: pre- and post-processing tools :tb(s=:)

:line

2.2 Making SPARTA :h4,link(start_2)

This section has the following sub-sections:

"Read this first"_#start_2_1
"Steps to build a SPARTA executable"_#start_2_2
"Common errors that can occur when making SPARTA"_#start_2_3
"Additional build tips"_#start_2_4
"Building for a Mac"_#start_2_5
"Building for Windows"_#start_2_6 :ul

:line

[{Read this first:}] :link(start_2_1)

Building SPARTA can be non-trivial.  You may need to edit a makefile,
there are compiler options to consider, additional libraries can be
used (MPI, JPEG).

Please read this section carefully.  If you are not comfortable with
makefiles, or building codes on a Unix platform, or running an MPI job
on your machine, please find a local expert to help you.

If you have a build problem that you are convinced is a SPARTA issue
(e.g. the compiler complains about a line of SPARTA source code), then
please send an email to the
"developers"_http://sparta.sandia.gov/authors.html.

If you succeed in building SPARTA on a new kind of machine, for which
there isn't a similar Makefile for in the src/MAKE directory, send it
to the developers and we'll include it in future SPARTA releases.

:line

[{Steps to build a SPARTA executable:}] :link(start_2_2)

[Step 0]

The src directory contains the C++ source and header files for SPARTA.
It also contains a top-level Makefile and a MAKE sub-directory with
low-level Makefile.* files for many machines.  From within the src
directory, type "make" or "gmake".  You should see a list of available
choices.  If one of those is the machine and options you want, you can
type a command like:

make g++
or
gmake mac :pre

Note that on a multi-processor or multi-core platform you can launch a
parallel make, by using the "-j" switch with the make command, which
will build SPARTA more quickly.

If you get no errors and an executable like spa_g++ or spa_mac is
produced, you're done; it's your lucky day.

[Step 1]

If Step 0 did not work, you will need to create a low-level Makefile
for your machine, like Makefile.foo.  Create a copy of an existing
src/MAKE/Makefile.* as a starting point.  The only portions of the
file you need to edit are the first line, the "compiler/linker
settings" section, and the "SPARTA-specific settings" section.

[Step 2]

Change the first line of src/MAKE/Makefile.foo to list the word "foo"
after the "#", and whatever other options it will set.  This is the
line you will see if you just type "make".

[Step 3]

The "compiler/linker settings" section lists compiler and linker
settings for your C++ compiler, including optimization flags.  You can
use g++, the open-source GNU compiler, which is available on all Unix
systems.  You can also use mpicc which will typically be available if
MPI is installed on your system, though you should check which actual
compiler it wraps.  Vendor compilers often produce faster code.  On
boxes with Intel CPUs, we suggest using the commercial Intel icc
compiler, which can be downloaded from "Intel's compiler site"_intel.

:link(intel,http://www.intel.com/software/products/noncom)

If building a C++ code on your machine requires additional libraries,
then you should list them as part of the LIB variable.

The DEPFLAGS setting is what triggers the C++ compiler to create a
dependency list for a source file.  This speeds re-compilation when
source (*.cpp) or header (*.h) files are edited.  Some compilers do
not support dependency file creation, or may use a different switch
than -D.  GNU g++ works with -D.  Note that when you build SPARTA for
the first time on a new platform, a long list of *.d files will be
printed out rapidly.  This is not an error; it is the Makefile doing
its normal creation of dependencies.

[Step 4]

The "system-specific settings" section has several parts.  Note that
if you change any -D setting in this section, you should do a full
re-compile, after typing "make clean", which will describe different
clean options.

The SPA_INC variable is used to include options that turn on ifdefs
within the SPARTA code.  The options that are currently recogized are:

-DSPARTA_GZIP
-DSPARTA_JPEG
-DSPARTA_PNG
-DSPARTA_MAP
-DSPARTA_SMALL
-DSPARTA_BIG
-DSPARTA_BIGBIG
-DSPARTA_LONGLONG_TO_LONG :ul

The read_data and dump commands will read/write gzipped files if you
compile with -DSPARTA_GZIP.  It requires that your Unix support the
"popen" command.

If you use -DSPARTA_JPEG and/or -DSPARTA_PNG, the "dump
image"_dump.html command will be able to write out JPEG and/or PNG
image files respectively. If not, it will only be able to write out
PPM image files.  For JPEG files, you must also link SPARTA with a
JPEG library, as described below.  For PNG files, you must also link
SPARTA with a PNG library, as described below.

If you use -DSPARTA_MAP, SPARTA will use the STL map class for hash
tables.  This is less efficient than the STL unordered map class which
is not yet supported by all C++ compilers.  The default is to use the
unordered map class, so only set -DSPARTA_MAP if the build complains
that unordered maps are not recognized.

Use at most one of the -DSPARTA_SMALL, -DSPARTA_BIG, -D-DSPARTA_BIGBIG
settings.  The default is -DSPARTA_BIG.  These refer to use of 4-byte
(small) vs 8-byte (big) integers within SPARTA, as described in
src/spatype.h.  The only reason to use the BIGBIG setting is to enable
simulation of large models with more than ~2 billion grid cells.  The
only reason to use the SMALL setting is if your machine does not
support 64-bit integers.

In all cases, the size of problem that can be run on a per-processor
basis is limited by 4-byte integer storage to about 2 billion
particles per processor (2^31), which should not normally be a
restriction since such a problem would have a huge per-processor
memory and would run very slowly in terms of CPU secs/timestep.

The -DSPARTA_LONGLONG_TO_LONG setting may be needed if your system or
MPI version does not recognize "long long" data types.  In this case a
"long" data type is likely already 64-bits, in which case this setting
will use that data type.

[Step 5]

The 3 MPI variables are used to specify an MPI library to build SPARTA
with. 

If you want SPARTA to run in parallel, you must have an MPI library
installed on your platform.  If you use an MPI-wrapped compiler, such
as "mpicc" to build, you should be able to leave these 3 variables
blank; the MPI wrapper knows where to find the needed files.  If not,
and MPI is installed on your system in the usual place (under
/usr/local), you also may not need to specify these 3 variables.  On
some large parallel machines which use "modules" for their
compile/link environements, you may simply need to include the correct
module in your build environment.  Or the parallel machine may have a
vendor-provided MPI which the compiler has no trouble finding.

Failing this, with these 3 variables you can specify where the mpi.h
file (MPI_INC) and the MPI library file (MPI_PATH) are found and the
name of the library file (MPI_LIB).  See Makefile.serial for an
example of how this can be done.

If you are installing MPI yourself, we recommend Argonne's MPICH 1.2
or 2.0 or OpenMPI.  MPICH can be downloaded from the "Argonne MPI
site"_http://www-unix.mcs.anl.gov/mpi.  OpenMPI can be downloaded the
"OpenMPI site"_http://www.open-mpi.org.  LAM MPI should also work.  If
you are running on a big parallel platform, your system admins or the
vendor should have already installed a version of MPI, which will be
faster than MPICH or OpenMPI or LAM, so find out how to build and link
with it.  If you use MPICH or OpenMPI or LAM, you will have to
configure and build it for your platform.  The MPI configure script
should have compiler options to enable you to use the same compiler
you use for the SPARTA build, which can avoid problems that can arise
when linking SPARTA to the MPI library.

If you just want to run SPARTA on a single processor, you can use the
dummy MPI library provided in src/STUBS, since you don't need a true
MPI library installed on your system.  You will also need to build the
STUBS library for your platform before making SPARTA itself.  From the
src directory, type "make stubs", or from the STUBS dir, type "make"
and it should create a libmpi.a suitable for linking to SPARTA.  If
this build fails, you will need to edit the STUBS/Makefile for your
platform.

The file STUBS/mpi.cpp provides a CPU timer function called
MPI_Wtime() that calls gettimeofday() .  If your system doesn't
support gettimeofday() , you'll need to insert code to call another
timer.  Note that the ANSI-standard function clock() rolls over after
an hour or so, and is therefore insufficient for timing long SPARTA
simulations.

[Step 6]

The 3 JPG variables allow you to specify a JPEG and/or PNG library
which LAMMPS uses when writing out JPEG or PNG files via the "dump
image"_dump_image.html command. These can be left blank if you do not
use the -DLAMMPS_JPEG or -DLAMMPS_PNG switches discussed above in Step
4, since in that case JPEG/PNG output will be disabled.

A standard JPEG library usually goes by the name libjpeg.a or
libjpeg.so and has an associated header file jpeglib.h. Whichever JPEG
library you have on your platform, you'll need to set the appropriate
JPG_INC, JPG_PATH, and JPG_LIB variables, so that the compiler and
linker can find it.

A standard PNG library usually goes by the name libpng.a or libpng.so
and has an associated header file png.h. Whichever PNG library you
have on your platform, you'll need to set the appropriate JPG_INC,
JPG_PATH, and JPG_LIB variables, so that the compiler and linker can
find it.

As before, if these header and library files are in the usual place on
your machine, you may not need to set these variables.

[Step 7]

That's it.  Once you have a correct Makefile.foo, you have installed
the optional SPARTA packages you want to include in your build, and
you have pre-built any other needed libraries (e.g. MPI), all you need
to do from the src directory is type this:

make foo
or
gmake foo :pre

You should get the executable spa_foo when the build is complete.

:line

[{Errors that can occur when making SPARTA:}] :link(start_2_3)

IMPORTANT NOTE: If an error occurs when building SPARTA, the compiler
or linker will state very explicitly what the problem is.  The error
message should give you a hint as to which of the steps above has
failed, and what you need to do in order to fix it.  Building a code
with a Makefile is a very logical process.  The compiler and linker
need to find the appropriate files and those files need to be
compatible with SPARTA source files.  When a make fails, there is
usually a very simple reason, which you or a local expert will need to
fix.

Here are two non-obvious errors that can occur:

(1) If the make command breaks immediately with errors that indicate
it can't find files with a "*" in their names, this can be because
your machine's native make doesn't support wildcard expansion in a
makefile.  Try gmake instead of make.  If that doesn't work, try using
a -f switch with your make command to use a pre-generated
Makefile.list which explicitly lists all the needed files, e.g.

make makelist
make -f Makefile.list g++
gmake -f Makefile.list mac :pre

The first "make" command will create a current Makefile.list with all
the file names in your src dir.  The 2nd "make" command (make or
gmake) will use it to build SPARTA.

(2) If you get an error that says something like 'identifier "atoll"
is undefined', then your machine does not support "long long"
integers.  Try using the -DSPARTA_LONGLONG_TO_LONG setting described
above in Step 4.

:line

[{Additional build tips:}] :link(start_2_4)

(1) Building SPARTA for multiple platforms.

You can make SPARTA for multiple platforms from the same src
directory.  Each target creates its own object sub-directory called
Obj_name where it stores the system-specific *.o files.

(2) Cleaning up.

Typing "make clean-all" or "make clean-foo" will delete *.o object
files created when SPARTA is built, for either all builds or for a
particular machine.

:line

[{Building for a Mac:}] :link(start_2_5)

OS X is BSD Unix, so it should just work.  See the Makefile.mac file.

:line

[{Building for Windows:}] :link(start_2_6)

At some point we may provide a pre-built Windows executable
for SPARTA.  Until then you will need to build an executable from 
source files.

One way to do this is install and use cygwin to build SPARTA with a
standard Linux make, just as you would on any Linux box.

You can also import the *.cpp and *.h files into Microsoft Visual
Studio.  If someone does this and wants to provide project files
or other Windows build tips, please send them to the developers
and we will include them in the distribution.

:line

2.4 Building SPARTA as a library :h4,link(start_4)

SPARTA can be built as a library, which can then be called from
another application or a scripting language.  See "this
section"_Section_howto.html#howto_7 for more info on coupling SPARTA
to other codes.  Building SPARTA as a library is done by typing

make makelib
make -f Makefile.lib foo
gmake -f Makefile.lib foo :pre

where foo is the machine name.  The first "make" command will create a
current Makefile.lib with all the file names in your src dir.  The 2nd
"make" or "gmake" command will use it to build SPARTA as a library.  This
requires that Makefile.foo have a library target (lib) and
system-specific settings for ARCHIVE and ARFLAGS.  See Makefile.g++
for an example.  The build will create the file libspa_foo.a which
another application can link to.

When used from a C++ program, the library allows one or more SPARTA
objects to be instantiated.  All of SPARTA is wrapped in a SPARTA_NS
namespace; you can safely use any of its classes and methods from
within your application code, as needed. 

When used from a C or Fortran program or a scripting language, the
library has a simple function-style interface, provided in
src/library.cpp and src/library.h.

See the sample codes examples/COUPLE/simple.cpp and simple.c as
examples of C++ and C codes that invoke SPARTA thru its library
interface.  There are other examples as well in the couple directory
which are discussed in examples/COUPLE/README.   See "this
section"_Section_python.html of the manual for a description of the
Python wrapper provided with SPARTA that operates through the SPARTA
library interface.

The files src/library.cpp and library.h contain the C-style interface
to SPARTA.  See "Section 4.6"_Section_howto.html#howto_6 of the manual
for a description of the interface and how to extend it for your
needs.

:line

2.5 Running SPARTA :h4,link(start_5)

By default, SPARTA runs by reading commands from stdin; e.g. spa_g++ <
in.file.  This means you first create an input script (e.g. in.file)
containing the desired commands.  "Section 3"_Section_commands.html of
the manual describes how input scripts are structured and what
commands they contain.

You can test SPARTA on any of the sample inputs provided in the
examples or bench directory.  Input scripts are named in.* and sample
outputs are named log.*.name.P where name is a machine and P is the
number of processors it was run on.

Here is how you might run one of the benchmarks using mpirun to launch
a parallel job:

cd src
make g++
cp spa_g++ ../bench
cd ../bench
mpirun -np 4 spa_g++ < in.free :pre

:line

The screen output from SPARTA is described in the next section.  As it
runs, SPARTA also writes a log.sparta file with the same information.

Note that this sequence of commands copies the SPARTA executable
(spa_g++) to the directory with the input files.  This may not be
necessary, but some versions of MPI reset the working directory to
where the executable is, rather than leave it as the directory where
you launch mpirun from (if you launch spa_g++ on its own and not under
mpirun).  If that happens, SPARTA will look for additional input files
and write its output files to the executable directory, rather than
your working directory, which is probably not what you want.

If SPARTA encounters errors in the input script or while running a
simulation it will print an ERROR message and stop or a WARNING
message and continue.  See "Section 10"_Section_errors.html for a
discussion of the various kinds of errors SPARTA can or can't detect,
a list of all ERROR and WARNING messages, and what to do about them.

SPARTA can run a problem on any number of processors, including a
single processor.  The random numbers used by each processor
will be different so you should only expect statistical consistency
if the same problem is run on varying numbers of processors.

SPARTA can run as large a problem as will fit in the physical memory
of one or more processors.  If you run out of memory, you must run on
more processors or setup a smaller problem.

:line

2.6 Command-line options :h4,link(start_6)

At run time, SPARTA recognizes several optional command-line switches
which may be used in any order.  Either the full word or a one-or-two
letter abbreviation can be used:

-e or -echo
-i or -in
-h or -help
-l or -log
-p or -partition
-pl or -plog
-ps or -pscreen
-sc or -screen
-v or -var :ul

For example, spa_g++ might be launched as follows:

mpirun -np 16 spa_g++ -v f tmp.out -l my.log -sc none < in.sphere
mpirun -np 16 spa_g++ -var f tmp.out -log my.log -screen none < in.sphere :pre

Here are the details on the options:

-echo style :pre

Set the style of command echoing.  The style can be {none} or {screen}
or {log} or {both}.  Depending on the style, each command read from
the input script will be echoed to the screen and/or logfile.  This
can be useful to figure out which line of your script is causing an
input error.  The default value is {log}.  The echo style can also be
set by using the "echo"_echo.html command in the input script itself.

-in file :pre

Specify a file to use as an input script.  This is an optional switch
when running SPARTA in one-partition mode.  If it is not specified,
SPARTA reads its input script from stdin - e.g. spa_g++ < in.run.
This is a required switch when running SPARTA in multi-partition mode,
since multiple processors cannot all read from stdin.

-help :pre

Print a list of options compiled into this executable for each SPARTA
style (fix, compute, collide, etc).  SPARTA will print the info and
immediately exit if this switch is used.

-log file :pre

Specify a log file for SPARTA to write status information to.  In
one-partition mode, if the switch is not used, SPARTA writes to the
file log.sparta.  If this switch is used, SPARTA writes to the
specified file.  In multi-partition mode, if the switch is not used, a
log.sparta file is created with hi-level status information.  Each
partition also writes to a log.sparta.N file where N is the partition
ID.  If the switch is specified in multi-partition mode, the hi-level
logfile is named "file" and each partition also logs information to a
file.N.  For both one-partition and multi-partition mode, if the
specified file is "none", then no log files are created.  Using a
"log"_log.html command in the input script will override this setting.
Option -plog will override the name of the partition log files file.N.

-partition 8x2 4 5 ... :pre

Invoke SPARTA in multi-partition mode.  When SPARTA is run on P
processors and this switch is not used, SPARTA runs in one partition,
i.e. all P processors run a single simulation.  If this switch is
used, the P processors are split into separate partitions and each
partition runs its own simulation.  The arguments to the switch
specify the number of processors in each partition.  Arguments of the
form MxN mean M partitions, each with N processors.  Arguments of the
form N mean a single partition with N processors.  The sum of
processors in all partitions must equal P.  Thus the command
"-partition 8x2 4 5" has 10 partitions and runs on a total of 25
processors.

The input script specifies what simulation is run on which partition;
see the "variable"_variable.html and "next"_next.html commands. "This
section"_Section_howto.html#howto_3 gives examples of how to use these
commands in this way.

-plog file :pre
 
Specify the base name for the partition log files, so partition N
writes log information to file.N. If file is none, then no partition
log files are created.  This overrides the filename specified in the
-log command-line option.  This option is useful when working with
large numbers of partitions, allowing the partition log files to be
suppressed (-plog none) or placed in a sub-directory (-plog
replica_files/log.sparta) If this option is not used the log file for
partition N is log.sparta.N or whatever is specified by the -log
command-line option.

-pscreen file :pre 

Specify the base name for the partition screen file, so partition N
writes screen information to file.N. If file is none, then no
partition screen files are created.  This overrides the filename
specified in the -screen command-line option.  This option is useful
when working with large numbers of partitions, allowing the partition
screen files to be suppressed (-pscreen none) or placed in a
sub-directory (-pscreen replica_files/screen) If this option is not
used the screen file for partition N is screen.N or whatever is
specified by the -screen command-line option.

-screen file :pre

Specify a file for SPARTA to write its screen information to.  In
one-partition mode, if the switch is not used, SPARTA writes to the
screen.  If this switch is used, SPARTA writes to the specified file
instead and you will see no screen output.  In multi-partition mode,
if the switch is not used, hi-level status information is written to
the screen.  Each partition also writes to a screen.N file where N is
the partition ID.  If the switch is specified in multi-partition mode,
the hi-level screen dump is named "file" and each partition also
writes screen information to a file.N.  For both one-partition and
multi-partition mode, if the specified file is "none", then no screen
output is performed. Option -pscreen will override the name of the 
partition screen files file.N.

-var name value1 value2 ... :pre

Specify a variable that will be defined for substitution purposes when
the input script is read.  "Name" is the variable name which can be a
single character (referenced as $x in the input script) or a full
string (referenced as $\{abc\}).  An "index-style
variable"_variable.html will be created and populated with the
subsequent values, e.g. a set of filenames.  Using this command-line
option is equivalent to putting the line "variable name index value1
value2 ..."  at the beginning of the input script.  Defining an index
variable as a command-line argument overrides any setting for the same
index variable in the input script, since index variables cannot be
re-defined.  See the "variable"_variable.html command for more info on
defining index and other kinds of variables and "Section
3.2"_Section_commands.html#cmd_2 for more info on using variables in
input scripts.

:line

2.7 SPARTA screen output :h4,link(start_7)

As SPARTA reads an input script, it prints information to both the
screen and a log file about significant actions it takes to setup a
simulation.  When the simulation is ready to begin, SPARTA performs
various initializations and prints the amount of memory (in MBytes per
processor) that the simulation requires.  It also prints details of
the initial state of the system.  During the run itself, statistical
information is printed periodically, every few timesteps.  When the
run concludes, SPARTA prints the final statistical state and a total
run time for the simulation.  It then appends statistics about the CPU
time and storage requirements for the simulation.  An example set of
statistics is shown here:

Loop time of 49.002 on 2 procs for 2004 atoms :pre

The first section gives the breakdown of the CPU run time (in seconds)
into major categories.  The second section lists the number of owned
atoms (Nlocal), ghost atoms (Nghost), and pair-wise neighbors stored
per processor.  The max and min values give the spread of these values
across processors with a 10-bin histogram showing the distribution.
The total number of histogram counts is equal to the number of
processors.
