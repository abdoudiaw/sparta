<HTML>
<CENTER><A HREF = "Section_commands.html">Previous Section</A> - <A HREF = "http://sparta.sandia.gov">SPARTA WWW Site</A> - <A HREF = "Manual.html">SPARTA Documentation</A> - <A HREF = "Section_commands.html#comm">SPARTA Commands</A> - <A HREF = "Section_example.html">Next Section</A> 
</CENTER>






<HR>

<H3>4. How-to discussions 
</H3>
<P>The following sections describe how to perform common tasks using
SPARTA, as well as provide some techinical details about how
SPARTA works.
</P>
<P>NOTE: add restarting a simulation, like in LAMMPS
</P>
4.1 <A HREF = "#howto_1">2d simulations</A><BR>
4.2 <A HREF = "#howto_2">Axisymmetric simulations</A><BR>
4.3 <A HREF = "#howto_3">Running multiple simulations from one input script</A><BR>
4.4 <A HREF = "#howto_4">Output from SPARTA (stats, dumps, computes, fixes, variables)</A><BR>
4.5 <A HREF = "#howto_5">Visualizing SPARTA snapshots</A><BR>
4.6 <A HREF = "#howto_6">Library interface to SPARTA</A><BR>
4.7 <A HREF = "#howto_7">Coupling SPARTA to other codes</A> <BR>
4.8 <A HREF = "#howto_8">Details of grid geometry in SPARTA</A><BR>
4.9 <A HREF = "#howto_9">Details of surfaces in SPARTA</A> <BR>

<P>The example input scripts included in the SPARTA distribution and
highlighted in <A HREF = "Section_example.html">Section 5</A> of the manual also
show how to setup and run various kinds of simulations.
</P>
<HR>

<HR>

<A NAME = "howto_1"></A><H4>6.1 2d simulations 
</H4>
<P>In SPARTA, as in other DSMC codes, a 2d simulation means that
particles move only in the xy plane, but still have all 3 xyz
components of velocity.  Only the xy components of velocity are used
to advect the particles, so that they stay in the xy plane, but all 3
components are used to compute collision parameters, temperatures,
etc.  Here are the steps to take in an input script to setup a 2d
model.
</P>
<UL><LI>Use the <A HREF = "dimension.html">dimension</A> command to specify a 2d simulation. 

<LI>Make the simulation box periodic in z via the <A HREF = "boundary.html">boundary</A>
command.  This is the default. 

<LI>Using the <A HREF = "create_box.html">create box</A> command, set the z boundaries
of the box to values that straddle the z = 0.0 plane.  I.e. zlo < 0.0
and zhi > 0.0.  Typical values are -0.5 and 0.5, but regardless of the
actual values, SPARTA computes the "volume" of 2d grid cells as if
their z-dimension length is 1.0, in whatever <A HREF = "units.html">units</A> are
defined.  This volume is used with the <A HREF = "global.html">global nrho</A>
setting to calculate numbers of particles to create or insert.  It is
also used to compute collision frequencies. 

<LI>If surfaces are defined via the <A HREF = "read_surf.html">read_surf</A> command,
use 2d objects defined by line segements. 
</UL>
<P>Many of the example input scripts included in the SPARTA distribution
are for 2d models.
</P>
<HR>

<A NAME = "howto_2"></A><H4>4.2 Axisymmetric simulations 
</H4>
<P>This section will be filled in when axisymmetry is fully implemented
in SPARTA.
</P>
<UL><LI>create box with ylo = 0.0 and zlo/zhi = 0.5
<LI>ylo boundary with "a" setting
<LI>cell weighting options 
</UL>
<HR>

<A NAME = "howto_3"></A><H4>4.3 Running multiple simulations from one input script 
</H4>
<P>This can be done in several ways.  See the documentation for
individual commands for more details on how these examples work.
</P>
<P>If "multiple simulations" means continue a previous simulation for
more timesteps, then you simply use the <A HREF = "run.html">run</A> command
multiple times.  For example, this script
</P>
<PRE>read_grid data.grid
create_particles 1000000
run 10000
run 10000
run 10000
run 10000
run 10000 
</PRE>
<P>would run 5 successive simulations of the same system for a total of
50,000 timesteps.
</P>
<P>If you wish to run totally different simulations, one after the other,
the <A HREF = "clear.html">clear</A> command can be used in between them to
re-initialize SPARTA.  For example, this script
</P>
<PRE>read_grid data.grid
create_particles 1000000
run 10000
clear
read_grid data.grid2
create_particles 500000
run 10000 
</PRE>
<P>would run 2 independent simulations, one after the other.
</P>
<P>For large numbers of independent simulations, you can use
<A HREF = "variable.html">variables</A> and the <A HREF = "next.html">next</A> and
<A HREF = "jump.html">jump</A> commands to loop over the same input script multiple
times with different settings.  For example, this script, named
in.flow
</P>
<PRE>variable d index run1 run2 run3 run4 run5 run6 run7 run8
shell cd $d
read_grid data.grid
create_particles 1000000
run 10000
shell cd ..
clear
next d
jump in.flow 
</PRE>
<P>would run 8 simulations in different directories, using a data.grid
file in each directory.  The same concept could be used to run the
same system at 8 different gas densities, using a density variable and
storing the output in different log and dump files, for example
</P>
<PRE>variable a loop 8
variable rho index 1.0e18 4.0e18 1.0e19 4.0e19 1.0e20 4.0e20 1.0e21 4.0e21
log log.$a
read data.grid
global nrho ${rho}
compute myGrid grid all n temp
dump 1 all grid 1000 dump.$a id c_myGrid
run 100000
clear
next rho
next a
jump in.flow 
</PRE>
<P>All of the above examples work whether you are running on 1 or
multiple processors, but assumed you are running SPARTA on a single
partition of processors.  SPARTA can be run on multiple partitions via
the "-partition" command-line switch as described in <A HREF = "Section_start.html#start_5">Section
2.5</A> of the manual.
</P>
<P>In the last 2 examples, if SPARTA were run on 3 partitions, the same
scripts could be used if the "index" and "loop" variables were
replaced with <I>universe</I>-style variables, as described in the
<A HREF = "variable.html">variable</A> command.  Also, the "next rho" and "next a"
commands would need to be replaced with a single "next a rho" command.
With these modifications, the 8 simulations of each script would run
on the 3 partitions one after the other until all were finished.
Initially, 3 simulations would be started simultaneously, one on each
partition.  When one finished, that partition would then start the 4th
simulation, and so forth, until all 8 were completed.
</P>
<HR>

<A NAME = "howto_4"></A><H4>4.4 Output from SPARTA (stats, dumps, computes, fixes, variables) 
</H4>
<P>There are four basic kinds of SPARTA output:
</P>
<UL><LI><A HREF = "stats_style.html">Statistical output</A>, which is a list of quantities
printed every few timesteps to the screen and logfile. 

<LI><A HREF = "dump.html">Dump files</A>, which contain snapshots of particle, grid
cell, or surface element quantities and are written at a specified
frequency. 

<LI>Certain fixes can output user-specified quantities directly to files:
<A HREF = "fix_ave_time.html">fix ave/time</A> for time averaging, and <A HREF = "fix_print.html">fix
print</A> for single-line output of
<A HREF = "variable.html">variables</A>.  Fix print can also output to the
screen. 

<LI><A HREF = "restart.html">Restart files</A>. 
</UL>
<P>A simulation prints one set of statistical output and (optionally)
restart files.  It can generate any number of dump files and fix
output files, depending on what <A HREF = "dump.html">dump</A> and <A HREF = "fix.html">fix</A>
commands you specify.
</P>
<P>As discussed below, SPARTA gives you a variety of ways to determine
what quantities are computed and printed when the statistics, dump, or
fix commands listed above perform output.  Throughout this discussion,
note that users can also add their own computes and fixes to SPARTA
(see <A HREF = "Section_modify.html">Section 10</A>) which can generate values that
can then be output with these commands.
</P>
<P>The following sub-sections discuss different SPARTA commands related
to output and the kind of data they operate on and produce:
</P>
<UL><LI><A HREF = "#global">Global/per-particle/per-grid/per-surf data</A>
<LI><A HREF = "#scalar">Scalar/vector/array data</A>
<LI><A HREF = "#stat">Statistical output</A>
<LI><A HREF = "#dump">Dump file output</A>
<LI><A HREF = "#fixoutput">Fixes that write output files</A>
<LI><A HREF = "#computeoutput">Computes that process output quantities</A>
<LI><A HREF = "#compute">Computes that generate values to output</A>
<LI><A HREF = "#fix">Fixes that generate values to output</A>
<LI><A HREF = "#variable">Variables that generate values to output</A>
<LI><A HREF = "#table">Summary table of output options and data flow between commands</A> 
</UL>
<H5><A NAME = "global"></A>Global/per-particle/per-grid/per-surf data 
</H5>
<P>Various output-related commands work with four different styles of
data: global, per particle, per grid, or per surf.  A global datum is
one or more system-wide values, e.g. the temperature of the system.  A
per particle datum is one or more values per partice, e.g. the kinetic
energy of each particle.  A per grid datum is one or more values per
grid cell, e.g. the temperature of the particles in the grid cell.  A
per surf datum is one or more values per surface element, e.g. the
count of particles that collided with the surface element.
</P>
<H5><A NAME = "scalar"></A>Scalar/vector/array data 
</H5>
<P>Global, per particle, per grid, and per surf datums can each come in
three kinds: a single scalar value, a vector of values, or a 2d array
of values.  The doc page for a "compute" or "fix" or "variable" that
generates data will specify both the style and kind of data it
produces, e.g. a per grid vector.
</P>
<P>When a quantity is accessed, as in many of the output commands
discussed below, it can be referenced via the following bracket
notation, where ID in this case is the ID of a compute.  The leading
"c_" would be replaced by "f_" for a fix, or "v_" for a variable:
</P>
<DIV ALIGN=center><TABLE  BORDER=1 >
<TR><TD >c_ID </TD><TD > entire scalar, vector, or array</TD></TR>
<TR><TD >c_ID[I] </TD><TD > one element of vector, one column of array</TD></TR>
<TR><TD >c_ID[I][J] </TD><TD > one element of array 
</TD></TR></TABLE></DIV>

<P>In other words, using one bracket reduces the dimension of the data
once (vector -> scalar, array -> vector).  Using two brackets reduces
the dimension twice (array -> scalar).  Thus a command that uses
scalar values as input can typically also process elements of a vector
or array.
</P>
<H5><A NAME = "stats"></A>Statistical output 
</H5>
<P>The frequency and format of statistical output is set by the
<A HREF = "stats.html">stats</A>, <A HREF = "stats_style.html">stats_style</A>, and
<A HREF = "stats_modify.html">stats_modify</A> commands.  The
<A HREF = "stats_style.html">stats_style</A> command also specifies what values are
calculated and written out.  Pre-defined keywords can be specified
(e.g. np, ncoll, etc).  Three additional kinds of keywords can also be
specified (c_ID, f_ID, v_name), where a <A HREF = "compute.html">compute</A> or
<A HREF = "fix.html">fix</A> or <A HREF = "variable.html">variable</A> provides the value to be
output.  In each case, the compute, fix, or variable must generate
global values to be used as an argument of the
<A HREF = "stats_style.html">stats_style</A> command.
</P>
<H5><A NAME = "dump"></A>Dump file output 
</H5>
<P>Dump file output is specified by the <A HREF = "dump.html">dump</A> and
<A HREF = "dump_modify.html">dump_modify</A> commands.  There are several
pre-defined formats: dump particle, dump grid, dump surf, etc.
</P>
<P>Each of these allows specification of what values are output with each
particle, grid cell, or surface element.  Pre-defined attributes can
be specified (e.g. id, x, y, z for particles or id, vol for grid
cells, etc).  Three additional kinds of keywords can also be specified
(c_ID, f_ID, v_name), where a <A HREF = "compute.html">compute</A> or <A HREF = "fix.html">fix</A>
or <A HREF = "variable.html">variable</A> provides the values to be output.  In each
case, the compute, fix, or variable must generate per particle, per
grid, or per surf values for input to the corresponding
<A HREF = "dump.html">dump</A> command.
</P>
<H5><A NAME = "fixoutput"></A>Fixes that write output files 
</H5>
<P>Two fixes take various quantities as input and can write output files:
<A HREF = "fix_ave_time.html">fix ave/time</A> and <A HREF = "fix_print.html">fix print</A>.
</P>
<P>The <A HREF = "fix_ave_time.html">fix ave/time</A> command enables direct output to
a file and/or time-averaging of global scalars or vectors.  The user
specifies one or more quantities as input.  These can be global
<A HREF = "compute.html">compute</A> values, global <A HREF = "fix.html">fix</A> values, or
<A HREF = "variable.html">variables</A> of any style except the particle style which
does not produce single values.  Since a variable can refer to
keywords used by the <A HREF = "stats_style.html">stats_style</A> command (like
particle count), a wide variety of quantities can be time averaged
and/or output in this way.  If the inputs are one or more scalar
values, then the fix generates a global scalar or vector of output.
If the inputs are one or more vector values, then the fix generates a
global vector or array of output.  The time-averaged output of this
fix can also be used as input to other output commands.
</P>
<P>The <A HREF = "fix_print.html">fix print</A> command can generate a line of output
written to the screen and log file or to a separate file, periodically
during a running simulation.  The line can contain one or more
<A HREF = "variable.html">variable</A> values for any style variable except the
particle style.  As explained above, variables themselves can contain
references to global values generated by <A HREF = "stats_style.html">stats
keywords</A>, <A HREF = "compute.html">computes</A>, <A HREF = "fix.html">fixes</A>,
or other <A HREF = "variable.html">variables</A>.  Thus the <A HREF = "fix_print.html">fix
print</A> command is a means to output a wide variety of
quantities separate from normal statistical or dump file output.
</P>
<H5><A NAME = "computeoutput"></A>Computes that process output quantities 
</H5>
<P>The <A HREF = "compute_reduce.html">compute reduce</A> command takes one or more per
particle or per grid or per surf vector quantities as inputs and
"reduces" them (sum, min, max, ave) to scalar quantities.  These are
produced as output values which can be used as input to other output
commands.
</P>
<H5><A NAME = "compute"></A>Computes that generate values to output 
</H5>
<P>Every <A HREF = "compute.html">compute</A> in SPARTA produces either global or per
particle or per grid or per surf values.  The values can be scalars or
vectors or arrays of data.  These values can be output using the other
commands described in this section.  The doc page for each compute
command describes what it produces.  Computes that produce per
particle or per grid or per surf values have the word "particle" or
"grid" or "surf" in their style name.  Computes without those words
produce global values.
</P>
<H5><A NAME = "fix"></A>Fixes that generate values to output 
</H5>
<P>Some <A HREF = "fix.html">fixes</A> in SPARTA produces either global or per particle
or per grid or per surf values which can be accessed by other
commands.  The values can be scalars or vectors or arrays of data.
These values can be output using the other commands described in this
section.  The doc page for each fix command tells whether it produces
any output quantities and describes them.
</P>
<P>Two fixes of particular interest for output are the <A HREF = "fix_ave_grid.html">fix
ave/grid</A> and <A HREF = "fix_ave_surf.html">fix ave/surf</A>
commands.
</P>
<P>The <A HREF = "fix_ave_grid.html">fix ave/grid</A> command enables time-averaging of
per grid vectors.  The user specifies one or more quantities as input.
These can be per grid vectors or ararys from <A HREF = "compute.html">compute</A> or
<A HREF = "fix.html">fix</A> commands.  If the input is a single vector, then the
fix generates a per grid vector.  If the input is multiple vectors or
array, the fix generates a per grid array.  The time-averaged output
of this fix can also be used as input to other output commands.
</P>
<P>The <A HREF = "fix_ave_surf.html">fix ave/surf</A> command enables time-averaging of
per surf vectors.  The user specifies one or more quantities as input.
These can be per surf vectors or ararys from <A HREF = "compute.html">compute</A> or
<A HREF = "fix.html">fix</A> commands.  If the input is a single vector, then the
fix generates a per surf vector.  If the input is multiple vectors or
array, the fix generates a per surf array.  The time-averaged output
of this fix can also be used as input to other output commands.
</P>
<H5><A NAME = "variable"></A>Variables that generate values to output 
</H5>
<P><A HREF = "variable.html">Variables</A> defined in an input script generate either a
global scalar value or a per particle vector (only particle-style
variables) when it is accessed.  The formulas used to define equal-
and particle-style variables can contain references to the
<A HREF = "stats_style.html">stats_style</A> keywords and to global and per particle
data generated by computes, fixes, and other variables.  The values
generated by variables can be output using the other commands
described in this section.
</P>
<H5><A NAME = "table"></A>Summary table of output options and data flow between commands 
</H5>
<P>This table summarizes the various commands that can be used for
generating output from SPARTA.  Each command produces output data of
some kind and/or writes data to a file.  Most of the commands can take
data from other commands as input.  Thus you can link many of these
commands together in pipeline form, where data produced by one command
is used as input to another command and eventually written to the
screen or to a file.  Note that to hook two commands together the
output and input data types must match, e.g. global/per atom/local
data and scalar/vector/array data.
</P>
<P>Also note that, as described above, when a command takes a scalar as
input, that could be an element of a vector or array.  Likewise a
vector input could be a column of an array.
</P>
<DIV ALIGN=center><TABLE  BORDER=1 >
<TR><TD >Command</TD><TD > Input</TD><TD > Output</TD><TD ></TD></TR>
<TR><TD ><A HREF = "stats_style.html">stats_style</A></TD><TD > global scalars</TD><TD > screen, log file</TD><TD ></TD></TR>
<TR><TD ><A HREF = "dump.html">dump particle</A></TD><TD > per particle vectors</TD><TD > dump file</TD><TD ></TD></TR>
<TR><TD ><A HREF = "dump.html">dump grid</A></TD><TD > per grid vectors</TD><TD > dump file</TD><TD ></TD></TR>
<TR><TD ><A HREF = "dump.html">dump surf</A></TD><TD > per surf vectors</TD><TD > dump file</TD><TD ></TD></TR>
<TR><TD ><A HREF = "fix_print.html">fix print</A></TD><TD > global scalar from variable</TD><TD > screen, file</TD><TD ></TD></TR>
<TR><TD ><A HREF = "print.html">print</A></TD><TD > global scalar from variable</TD><TD > screen</TD><TD ></TD></TR>
<TR><TD ><A HREF = "compute.html">computes</A></TD><TD > N/A</TD><TD > global or per particle/grid/surf scalar/vector/array</TD><TD ></TD></TR>
<TR><TD ><A HREF = "fix.html">fixes</A></TD><TD > N/A</TD><TD > global or per particle/grid/surf scalar/vector/array</TD><TD ></TD></TR>
<TR><TD ><A HREF = "variable.html">variables</A></TD><TD > global scalars, per particle vectors</TD><TD > global scalar, per particle vector</TD><TD ></TD></TR>
<TR><TD ><A HREF = "compute_reduce.html">compute reduce</A></TD><TD > per particle/grid/surf vectors</TD><TD > global scalar/vector</TD><TD ></TD></TR>
<TR><TD ><A HREF = "fix_ave_time.html">fix ave/time</A></TD><TD > global scalars/vectors</TD><TD > global scalar/vector/array, file</TD><TD ></TD></TR>
<TR><TD ><A HREF = "fix_ave_grid.html">fix ave/grid</A></TD><TD > per grid vectors/arrays</TD><TD > per grid vector/array</TD><TD ></TD></TR>
<TR><TD ><A HREF = "fix_ave_surf.html">fix ave/surf</A></TD><TD > per surf vectors/arrays</TD><TD > per surf vector/array</TD><TD ></TD></TR>
<TR><TD >
</TD></TR></TABLE></DIV>

<HR>

<A NAME = "howto_5"></A><H4>4.5 Visualizing SPARTA snapshots 
</H4>
<P>The <A HREF = "dump_image.html">dump image</A> command can be used to do on-the-fly
visualization as a simulation proceeds.  It works by creating a series
of JPG or PNG or PPM files on specified timesteps, as well as movies.
The images can include particles, grid cell quantities, and/or surface
element quantities.  This is not a substitute for using an interactive
visualization package in post-processing mode, but on-the-fly
visualization can be useful for debugging or making a high-quality
image of a particular snapshot of the simulation.
</P>
<P>The <A HREF = "dump.html">dump</A> command can be used to create snapshots of
particle, grid cell, or surface element data as a simulation runs.
These can be post-processed and read in to other visualization
packages.
</P>
<P>A Python-based toolkit distributed by our group can read SPARTA
particle dump files with columns of user-specified particle
information, and convert them to various formats or pipe them into
visualization software directly.  See the <A HREF = "http://www.sandia.gov/~sjplimp/pizza.html">Pizza.py WWW site</A>
for details.  Specifically, Pizza.py can convert SPARTA particle dump
files into PDB, XYZ, <A HREF = "http://www.ensight.com">Ensight</A>, and VTK formats.  Pizza.py can
pipe SPARTA dump files directly into the Raster3d and RasMol
visualization programs.  Pizza.py has tools that do interactive 3d
OpenGL visualization and one that creates SVG images of dump file
snapshots.
</P>
<P>Additional Pizza.py tools may be added that allow visualization of
surface and grid cell information as output by SPARTA.
</P>






<HR>

<A NAME = "howto_6"></A><H4>4.6 Library interface to SPARTA 
</H4>
<P>As described in <A HREF = "Section_start.html#start_3">Section 2.3</A>, SPARTA can
be built as a library, so that it can be called by another code, used
in a <A HREF = "Section_howto.html#howto_7">coupled manner</A> with other codes, or
driven through a <A HREF = "Section_python.html">Python interface</A>.
</P>
<P>All of these methodologies use a C-style interface to SPARTA that is
provided in the files src/library.cpp and src/library.h.  The
functions therein have a C-style argument list, but contain C++ code
you could write yourself in a C++ application that was invoking SPARTA
directly.  The C++ code in the functions illustrates how to invoke
internal SPARTA operations.  Note that SPARTA classes are defined
within a SPARTA namespace (SPARTA_NS) if you use them from another C++
application.
</P>
<P>Library.cpp contains these 4 functions:
</P>
<PRE>void sparta_open(int, char **, MPI_Comm, void **);
void sparta_close(void *);
void sparta_file(void *, char *);
char *sparta_command(void *, char *); 
</PRE>
<P>The sparta_open() function is used to initialize SPARTA, passing in a
list of strings as if they were <A HREF = "Section_start.html#start_5">command-line
arguments</A> when SPARTA is run in
stand-alone mode from the command line, and a MPI communicator for
SPARTA to run under.  It returns a ptr to the SPARTA object that is
created, and which is used in subsequent library calls.  The
sparta_open() function can be called multiple times, to create
multiple instances of SPARTA.
</P>
<P>SPARTA will run on the set of processors in the communicator.  This
means the calling code can run SPARTA on all or a subset of
processors.  For example, a wrapper script might decide to alternate
between SPARTA and another code, allowing them both to run on all the
processors.  Or it might allocate half the processors to SPARTA and
half to the other code and run both codes simultaneously before
syncing them up periodically.  Or it might instantiate multiple
instances of SPARTA to perform different calculations.
</P>
<P>The sparta_close() function is used to shut down an instance of SPARTA
and free all its memory.
</P>
<P>The sparta_file() and sparta_command() functions are used to pass a
file or string to SPARTA as if it were an input script or single
command in an input script.  Thus the calling code can read or
generate a series of SPARTA commands one line at a time and pass it
thru the library interface to setup a problem and then run it,
interleaving the sparta_command() calls with other calls to extract
information from SPARTA, perform its own operations, or call another
code's library.
</P>
<P>Other useful functions are also included in library.cpp. For example:
</P>
<PRE>void *sparta_extract_global(void *, char *)
void *sparta_extract_compute(void *, char *, int, int)
void *sparta_extract_variable(void *, char *, char *) 
</PRE>
<P>This can extract various global quantities from SPARTA as well as
values calculated by a compute or variable.  See the library.cpp file
and its associated header file library.h for details.
</P>
<P>Other functions may be added to the library interface as needed to
allow reading from or writing to internal SPARTA data structures. 
</P>
<P>The key idea of the library interface is that you can write any
functions you wish to define how your code talks to SPARTA and add
them to src/library.cpp and src/library.h, as well as to the <A HREF = "Section_python.html">Python
interface</A>.  The routines you add can in principle
access or change any SPARTA data you wish.  The examples/COUPLE and
python directories have example C++ and C and Python codes which show
how a driver code can link to SPARTA as a library, run SPARTA on a
subset of processors, grab data from SPARTA, change it, and put it
back into SPARTA.
</P>
<HR>

<A NAME = "howto_7"></A><H4>4.7 Coupling SPARTA to other codes 
</H4>
<P>SPARTA is designed to allow it to be coupled to other codes.  For
example, a continuum finite element (FE) simulation might use SPARTA
grid cell quantities as boundary conditions on FE nodal points,
compute a FE solution, and return continuum flow conditions as
boundary conditions for SPARTA to use.
</P>
<P>SPARTA can be coupled to other codes in at least 3 ways.  Each has
advantages and disadvantages, which you'll have to think about in the
context of your application.
</P>
<P>(1) Define a new <A HREF = "fix.html">fix</A> command that calls the other code.  In
this scenario, SPARTA is the driver code.  During its timestepping,
the fix is invoked, and can make library calls to the other code,
which has been linked to SPARTA as a library.  See <A HREF = "Section_modify.html">Section
8</A> of the documentation for info on how to add a
new fix to SPARTA.
</P>
<P>(2) Define a new SPARTA command that calls the other code.  This is
conceptually similar to method (1), but in this case SPARTA and the
other code are on a more equal footing.  Note that now the other code
is not called during the timestepping of a SPARTA run, but between
runs.  The SPARTA input script can be used to alternate SPARTA runs
with calls to the other code, invoked via the new command.  The
<A HREF = "run.html">run</A> command facilitates this with its <I>every</I> option, which
makes it easy to run a few steps, invoke the command, run a few steps,
invoke the command, etc.
</P>
<P>In this scenario, the other code can be called as a library, as in
(1), or it could be a stand-alone code, invoked by a system() call
made by the command (assuming your parallel machine allows one or more
processors to start up another program).  In the latter case the
stand-alone code could communicate with SPARTA thru files that the
command writes and reads.
</P>
<P>See <A HREF = "Section_modify.html">Section_modify</A> of the documentation for how
to add a new command to SPARTA.
</P>
<P>(3) Use SPARTA as a library called by another code.  In this case the
other code is the driver and calls SPARTA as needed.  Or a wrapper
code could link and call both SPARTA and another code as libraries.
Again, the <A HREF = "run.html">run</A> command has options that allow it to be
invoked with minimal overhead (no setup or clean-up) if you wish to do
multiple short runs, driven by another program.
</P>
<P>Examples of driver codes that call SPARTA as a library are included in
the examples/COUPLE directory of the SPARTA distribution; see
examples/COUPLE/README for more details:
</P>
<P><A HREF = "Section_start.html#start3">Section 2.3</A> of the manual describes how to
build SPARTA as a library.  Once this is done, you can interface with
SPARTA either via C++, C, Fortran, or Python (or any other language
that supports a vanilla C-like interface).  For example, from C++ you
could create one (or more) "instances" of SPARTA, pass it an input
script to process, or execute individual commands, all by invoking the
correct class methods in SPARTA.  From C or Fortran you can make
function calls to do the same things.  See
<A HREF = "Section_python.html">Section_9</A> of the manual for a description of the
Python wrapper provided with SPARTA that operates through the SPARTA
library interface.
</P>
<P>The files src/library.cpp and library.h contain the C-style interface
to SPARTA.  See <A HREF = "#howto_6">Section 4.6</A> of the manual for a description
of the interface and how to extend it for your needs.
</P>
<P>Note that the sparta_open() function that creates an instance of
SPARTA takes an MPI communicator as an argument.  This means that
instance of SPARTA will run on the set of processors in the
communicator.  Thus the calling code can run SPARTA on all or a subset
of processors.  For example, a wrapper script might decide to
alternate between SPARTA and another code, allowing them both to run
on all the processors.  Or it might allocate half the processors to
SPARTA and half to the other code and run both codes simultaneously
before syncing them up periodically.  Or it might instantiate multiple
instances of SPARTA to perform different calculations.
</P>
<HR>

<A NAME = "howto_8"></A><H4>4.8 Details of grid geometry in SPARTA 
</H4>
<P>SPARTA overlays a grid over the simulation domain which is used to
track particles and to co-locate particles in the same grid cell for
performing collision and chemistry operations.  Surface elements are
also assigned to grid cells they intersect with, so that
particle/surface collisions can be efficiently computed.
</P>
<P>SPARTA uses a Cartesian hierarchical grid, which is defined in the
following manner.  Cartesian means that the faces of a grid cell, at
any level of the hierarchy, are aligned with the Cartesian xyz axes.
I.e. each grid cell is an axis-aligned pallelpiped or rectangular box.
The entire simulation box is the single "root" grid cell at level 0 of
the hierarchy.  It is sub-divided into a regular Nx by Ny by Nz grid
of cells, all at level 1 of the hierarchy.  Regular means all the
Nx*Ny*Nz sub-divided cells within a single parent cell are the same
size.  Each Nx,Ny,Nz value >= 1 (although if Nx = Ny = Nz = 1 then
there is no sub-division).  Any or all of the cells at level 1 can be
further sub-divided in the same manner to create cells at level 2, and
recursively for level 3,4,etc.  The Nx,Ny,Nz values for sub-dividing
an individual parent cell can be uniquely chosen.  For example all
level 2 cells, do not need to be sub-divided using the same Nx,Ny,Nz
values.  Grids for 2d and 3d simulations (see the
<A HREF = "dimension.html">dimension</A>) follow the same rules, except that Nz = 1
is required at every level for 2d grids.
</P>
<P>Note that a 3d oct-tree (quad-tree in 2d) is a special case of the
SPARTA hierarchical grid, where Nx = Ny = Nz = 2 is always used to
sub-divide grid cells.
</P>
<P>In the rest of the SPARTA manual, the following terminology is used to
refer to the hierarchical grid.  The flow region is the portion of the
simulation domain that is "outside" any surface objects and is
typically filled with particles.
</P>
<UL><LI>root cell = the simulation box itself
<LI>parent cell = a grid cell at any level that is sub-divided further
<LI>child cell = a grid cell that is not sub-divided further
<LI>unsplit cell = a child cell not intersected by any surface elements
<LI>cut cell = a child cell intersected by one or more surface elements so that one portion of the cell is in the flow region
<LI>split cell = a child cell that is intersected by two or more surface elemments so that two or more disjoint portions of the cell are in the flow region
<LI>sub cell = one disjoint portion of a split cell in the flow region 
</UL>
<P>The list of parent cells in a simulation is stored by every processor
and is read in by the <A HREF = "read_grid.html">read_grid</A> command, or defined
by the <A HREF = "create_grid.html">create_grid</A> command.  The list of child
cells is inferred by the same 2 commands and the union of all child
cells is the entire simulation domain.  Child cells are distributed
across processors, so that each child cell is owned by exactly one
processor, as discussed below.
</P>
<P>When surface objects are defined via the <A HREF = "read_surf.html">read_surf</A>
command, they intersect with child cells.  Child cells that are not
intersected by any surface elements are unsplit cells.  If a child
cell is intersected in such a manner that it is partitioned into two
contiguous volumes, one in the flow region, the other inside a surface
object, then it is a cut cell.  SPARTA calculates the volume of the
flow region for the cell.  This is the usual case.  Sometimes a cell
can be partitioned by surface elements such that more than one
contiguous flow region is created.  Then it is a split cell and the
two or more contiguous flow regions are each sub cells of the split
cell.
</P>
<P>The union of (1) unsplit cells that are in the flow region (not
entirely interior to a surface object) and (2) flow region portions of
cut cells and (3) sub cells is the entire flow region of the
simulation domain.
</P>
<P>describe cell
IDs
</P>
<P>The <A HREF = "create_grid.html">create_grid</A> and
<A HREF = "balance.html">balance</A> and <A HREF = "fix_balance.html">fix balance</A> commands
affect the assignment of child cells to processors.
</P>
<P>Depending on the specified keyword, the grid cells assigned to each
processor by this command will either be "clumped" or "dispersed".
</P>
<P>Clumped means each processor's cells will be geometrically compact.
Dispersed means the processor's cells will be geometrically dispersed
across the simulation domain and so they cannot be enclosed in a small
bounding box.
</P>
<P>Various commands have similar effects on grid cell assignment, so it
is important to understand the difference between the two cases and
the effects they can have on performance of a simulation.  For example
the create_grid and read_grid commands may produce dispersed
assignments, depending on the options used, which can be converted to
a clumped assignment by the balance_grid command.
</P>
<P>Simulation typically run faster with clumped grid cell assignments.
This is because the cost of communicating particles is reduced if
particles that move to a neighboring grid cell often stay
on-processor.  Similarly, some stages of simulation setup may run
faster with a clumped assignment.  For example the finding of nearby
ghost grid cells and the computation of surface element intersections
with grid cells.  The latter operation is invoked when the
<A HREF = "read_surf.html">read_surf</A> command is used.
</P>
<P>If the spatial distribution of particles is highly irregular and/or
dynamically changing, or if the computational work per grid cell is
otherwise highly imbalanced, a clumped assignment of grid cells to
processors may not lead to optimal balancing.  In these scenarios a
dispersed assignment of grid cells to processsors may run faster even
with the overhead of increased particle communication.  This is
because (somewhat) randomly assigning grid cells to processors can
balance the computational load in a statistical sense.
</P>
<HR>

<A NAME = "howto_9"></A><H4>4.9 Details of surfaces in SPARTA 
</H4>
<P>TODO: describe watertight rule, surf IDs
</P>
<P>how you can have multiple objects in one simulation
</P>
<P>how to assign different collision models to different surfs
</P>
<P>how to clip surf to simulation box, what to watch out for
</P>
<P>kinds of surfs that are illegal:
  infininitly thin, duplicate points, touching, etc
</P>
</HTML>
