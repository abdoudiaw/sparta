"Previous Section"_Section_commands.html - "SPARTA WWW Site"_sws - "SPARTA Documentation"_sd - "SPARTA Commands"_sc - "Next Section"_Section_example.html :c

:link(sws,http://sparta.sandia.gov)
:link(sd,Manual.html)
:link(sc,Section_commands.html#comm)

:line 

4. How-to discussions :h3

The following sections describe how to perform common tasks using
SPARTA, as well as provide some techinical details about how
SPARTA works.

4.1 "2d simulations"_#howto_1
4.2 "Axisymmetric simulations"_#howto_2
4.3 "Running multiple simulations from one input script"_#howto_3
4.4 "Output from SPARTA (stats, dumps, computes, fixes, variables)"_#howto_4
4.5 "Visualizing SPARTA snapshots"_#howto_5
4.6 "Library interface to SPARTA"_#howto_6
4.7 "Coupling SPARTA to other codes"_#howto_7 
4.8 "Details of grid geometry in SPARTA"_#howto_8
4.9 "Details of surfaces in SPARTA"_#howto_9 :all(b)

The example input scripts included in the SPARTA distribution and
highlighted in "Section 5"_Section_example.html of the manual also
show how to setup and run various kinds of simulations.

:line
:line

6.1 2d simulations :link(howto_1),h4

Use the "dimension"_dimension.html command to specify a 2d simulation.

Make the simulation box periodic in z via the "boundary"_boundary.html
command.  This is the default.

Using the "create box"_create_box.html command, set the z boundaries
of the box zlo = -0.5 to and zhi = 0.5, so that the z-dimension box
length is 1.0 (in whatever "units"_units.html are defined) and it
straddles the z = 0.0 plane.  This insures that input and output
densities, e.g. via the "global nrho"_global.html command, are the
same in 1/length^2 and 1/length^3 units.  Thus if the
"create_particles"_create_particles.html command is used to create
particles in a 3d grid cell whose z-dimension is 1.0, the same number
of particles will be created in a 2d grid cell with the same x and y
dimensions.

TODO: is -0.5 and 0.5 required or OK not to do this?

TODO: how does SPARTA really do a 2d simulation?  continues to
treat velocity as 3d, so collisions, etc don't change

Many of the example input scripts included in the SPARTA distribution
are for 2d models.

:line

4.2 Axisymmetric simulations :link(howto_2),h4

TODO: describe commands when have a working example

create box with ylo = 0.0 and zlo/zhi = 0.5
boundary a
cell weighting :ul

:line

4.3 Running multiple simulations from one input script :link(howto_3),h4

This can be done in several ways.  See the documentation for
individual commands for more details on how these examples work.

If "multiple simulations" means continue a previous simulation for
more timesteps, then you simply use the "run"_run.html command
multiple times.  For example, this script

read_grid data.grid
create_particles 1000000
run 10000
run 10000
run 10000
run 10000
run 10000 :pre

would run 5 successive simulations of the same system for a total of
50,000 timesteps.

If you wish to run totally different simulations, one after the other,
the "clear"_clear.html command can be used in between them to
re-initialize SPARTA.  For example, this script

read_grid data.grid
create_particles 1000000
run 10000
clear
read_grid data.grid2
create_particles 500000
run 10000 :pre

would run 2 independent simulations, one after the other.

For large numbers of independent simulations, you can use
"variables"_variable.html and the "next"_next.html and
"jump"_jump.html commands to loop over the same input script multiple
times with different settings.  For example, this script, named
in.flow

variable d index run1 run2 run3 run4 run5 run6 run7 run8
shell cd $d
read_grid data.grid
create_particles 1000000
run 10000
shell cd ..
clear
next d
jump in.flow :pre

would run 8 simulations in different directories, using a data.grid
file in each directory.  The same concept could be used to run the
same system at 8 different gas densities, using a density variable and
storing the output in different log and dump files, for example

variable a loop 8
variable rho index 1.0e18 4.0e18 1.0e19 4.0e19 1.0e20 4.0e20 1.0e21 4.0e21
log log.$a
read data.grid
global nrho $\{rho\}
compute myGrid grid all n temp
dump 1 all grid 1000 dump.$a id c_myGrid
run 100000
clear
next rho
next a
jump in.flow :pre

All of the above examples work whether you are running on 1 or
multiple processors, but assumed you are running SPARTA on a single
partition of processors.  SPARTA can be run on multiple partitions via
the "-partition" command-line switch as described in "Section
2.5"_Section_start.html#start_5 of the manual.

In the last 2 examples, if SPARTA were run on 3 partitions, the same
scripts could be used if the "index" and "loop" variables were
replaced with {universe}-style variables, as described in the
"variable"_variable.html command.  Also, the "next rho" and "next a"
commands would need to be replaced with a single "next a rho" command.
With these modifications, the 8 simulations of each script would run
on the 3 partitions one after the other until all were finished.
Initially, 3 simulations would be started simultaneously, one on each
partition.  When one finished, that partition would then start the 4th
simulation, and so forth, until all 8 were completed.

:line

4.4 Output from SPARTA (stats, dumps, computes, fixes, variables) :link(howto_4),h4

There are four basic kinds of SPARTA output:

"Statistical output"_stats_style.html, which is a list of quantities
printed every few timesteps to the screen and logfile. :ulb,l

"Dump files"_dump.html, which contain snapshots of particle, grid
cell, or surface element quantities and are written at a specified
frequency. :l

Certain fixes can output user-specified quantities directly to files:
"fix ave/time"_fix_ave_time.html for time averaging, and "fix
print"_fix_print.html for single-line output of
"variables"_variable.html.  Fix print can also output to the
screen. :l

"Restart files"_restart.html. :l,ule

IMPORTANT NOTE: Restart files are not yet implemented in SPARTA.

A simulation prints one set of statistical output and (optionally)
restart files.  It can generate any number of dump files and fix
output files, depending on what "dump"_dump.html and "fix"_fix.html
commands you specify.

As discussed below, SPARTA gives you a variety of ways to determine
what quantities are computed and printed when the statistics, dump, or
fix commands listed above perform output.  Throughout this discussion,
note that users can also add their own computes and fixes to SPARTA
(see "Section 10"_Section_modify.html) which can generate values that
can then be output with these commands.

The following sub-sections discuss different SPARTA commands related
to output and the kind of data they operate on and produce:

"Global/per-particle/per-grid/per-surf data"_#global
"Scalar/vector/array data"_#scalar
"Statistical output"_#stat
"Dump file output"_#dump
"Fixes that write output files"_#fixoutput
"Computes that process output quantities"_#computeoutput
"Computes that generate values to output"_#compute
"Fixes that generate values to output"_#fix
"Variables that generate values to output"_#variable
"Summary table of output options and data flow between commands"_#table :ul

Global/per-particle/per-grid/per-surf data :h5,link(global)

Various output-related commands work with four different styles of
data: global, per particle, per grid, or per surf.  A global datum is
one or more system-wide values, e.g. the temperature of the system.  A
per particle datum is one or more values per partice, e.g. the kinetic
energy of each particle.  A per grid datum is one or more values per
grid cell, e.g. the temperature of the particles in the grid cell.  A
per surf datum is one or more values per surface element, e.g. the
count of particles that collided with the surface element.

Scalar/vector/array data :h5,link(scalar)

Global, per particle, per grid, and per surf datums can each come in
three kinds: a single scalar value, a vector of values, or a 2d array
of values.  The doc page for a "compute" or "fix" or "variable" that
generates data will specify both the style and kind of data it
produces, e.g. a per grid vector.

When a quantity is accessed, as in many of the output commands
discussed below, it can be referenced via the following bracket
notation, where ID in this case is the ID of a compute.  The leading
"c_" would be replaced by "f_" for a fix, or "v_" for a variable:

c_ID | entire scalar, vector, or array
c_ID\[I\] | one element of vector, one column of array
c_ID\[I\]\[J\] | one element of array :tb(s=|)

In other words, using one bracket reduces the dimension of the data
once (vector -> scalar, array -> vector).  Using two brackets reduces
the dimension twice (array -> scalar).  Thus a command that uses
scalar values as input can typically also process elements of a vector
or array.

Statistical output :h5,link(stats)

The frequency and format of statistical output is set by the
"stats"_stats.html, "stats_style"_stats_style.html, and
"stats_modify"_stats_modify.html commands.  The
"stats_style"_stats_style.html command also specifies what values are
calculated and written out.  Pre-defined keywords can be specified
(e.g. np, ncoll, etc).  Three additional kinds of keywords can also be
specified (c_ID, f_ID, v_name), where a "compute"_compute.html or
"fix"_fix.html or "variable"_variable.html provides the value to be
output.  In each case, the compute, fix, or variable must generate
global values to be used as an argument of the
"stats_style"_stats_style.html command.

Dump file output :h5,link(dump)

Dump file output is specified by the "dump"_dump.html and
"dump_modify"_dump_modify.html commands.  There are several
pre-defined formats: dump particle, dump grid, dump surf, etc.

Each of these allows specification of what values are output with each
particle, grid cell, or surface element.  Pre-defined attributes can
be specified (e.g. id, x, y, z for particles or id, vol for grid
cells, etc).  Three additional kinds of keywords can also be specified
(c_ID, f_ID, v_name), where a "compute"_compute.html or "fix"_fix.html
or "variable"_variable.html provides the values to be output.  In each
case, the compute, fix, or variable must generate per particle, per
grid, or per surf values for input to the corresponding
"dump"_dump.html command.

Fixes that write output files :h5,link(fixoutput)

Two fixes take various quantities as input and can write output files:
"fix ave/time"_fix_ave_time.html and "fix print"_fix_print.html.

The "fix ave/time"_fix_ave_time.html command enables direct output to
a file and/or time-averaging of global scalars or vectors.  The user
specifies one or more quantities as input.  These can be global
"compute"_compute.html values, global "fix"_fix.html values, or
"variables"_variable.html of any style except the particle style which
does not produce single values.  Since a variable can refer to
keywords used by the "stats_style"_stats_style.html command (like
particle count), a wide variety of quantities can be time averaged
and/or output in this way.  If the inputs are one or more scalar
values, then the fix generates a global scalar or vector of output.
If the inputs are one or more vector values, then the fix generates a
global vector or array of output.  The time-averaged output of this
fix can also be used as input to other output commands.

The "fix print"_fix_print.html command can generate a line of output
written to the screen and log file or to a separate file, periodically
during a running simulation.  The line can contain one or more
"variable"_variable.html values for any style variable except the
particle style.  As explained above, variables themselves can contain
references to global values generated by "stats
keywords"_stats_style.html, "computes"_compute.html, "fixes"_fix.html,
or other "variables"_variable.html.  Thus the "fix
print"_fix_print.html command is a means to output a wide variety of
quantities separate from normal statistical or dump file output.

Computes that process output quantities :h5,link(computeoutput)

The "compute reduce"_compute_reduce.html command takes one or more per
particle or per grid or per surf vector quantities as inputs and
"reduces" them (sum, min, max, ave) to scalar quantities.  These are
produced as output values which can be used as input to other output
commands.

Computes that generate values to output :h5,link(compute)

Every "compute"_compute.html in SPARTA produces either global or per
particle or per grid or per surf values.  The values can be scalars or
vectors or arrays of data.  These values can be output using the other
commands described in this section.  The doc page for each compute
command describes what it produces.  Computes that produce per
particle or per grid or per surf values have the word "particle" or
"grid" or "surf" in their style name.  Computes without those words
produce global values.

Fixes that generate values to output :h5,link(fix)

Some "fixes"_fix.html in SPARTA produces either global or per particle
or per grid or per surf values which can be accessed by other
commands.  The values can be scalars or vectors or arrays of data.
These values can be output using the other commands described in this
section.  The doc page for each fix command tells whether it produces
any output quantities and describes them.

Two fixes of particular interest for output are the "fix
ave/grid"_fix_ave_grid.html and "fix ave/surf"_fix_ave_surf.html
commands.

The "fix ave/grid"_fix_ave_grid.html command enables time-averaging of
per grid vectors.  The user specifies one or more quantities as input.
These can be per grid vectors or ararys from "compute"_compute.html or
"fix"_fix.html commands.  If the input is a single vector, then the
fix generates a per grid vector.  If the input is multiple vectors or
array, the fix generates a per grid array.  The time-averaged output
of this fix can also be used as input to other output commands.

The "fix ave/surf"_fix_ave_surf.html command enables time-averaging of
per surf vectors.  The user specifies one or more quantities as input.
These can be per surf vectors or ararys from "compute"_compute.html or
"fix"_fix.html commands.  If the input is a single vector, then the
fix generates a per surf vector.  If the input is multiple vectors or
array, the fix generates a per surf array.  The time-averaged output
of this fix can also be used as input to other output commands.

Variables that generate values to output :h5,link(variable)

"Variables"_variable.html defined in an input script generate either a
global scalar value or a per particle vector (only particle-style
variables) when it is accessed.  The formulas used to define equal-
and particle-style variables can contain references to the
"stats_style"_stats_style.html keywords and to global and per particle
data generated by computes, fixes, and other variables.  The values
generated by variables can be output using the other commands
described in this section.

Summary table of output options and data flow between commands :h5,link(table)

This table summarizes the various commands that can be used for
generating output from SPARTA.  Each command produces output data of
some kind and/or writes data to a file.  Most of the commands can take
data from other commands as input.  Thus you can link many of these
commands together in pipeline form, where data produced by one command
is used as input to another command and eventually written to the
screen or to a file.  Note that to hook two commands together the
output and input data types must match, e.g. global/per atom/local
data and scalar/vector/array data.

Also note that, as described above, when a command takes a scalar as
input, that could be an element of a vector or array.  Likewise a
vector input could be a column of an array.

Command: Input: Output:
"stats_style"_stats_style.html: global scalars: screen, log file:
"dump particle"_dump.html: per particle vectors: dump file:
"dump grid"_dump.html: per grid vectors: dump file:
"dump surf"_dump.html: per surf vectors: dump file:
"fix print"_fix_print.html: global scalar from variable: screen, file:
"print"_print.html: global scalar from variable: screen:
"computes"_compute.html: N/A: global or per particle/grid/surf scalar/vector/array:
"fixes"_fix.html: N/A: global or per particle/grid/surf scalar/vector/array:
"variables"_variable.html: global scalars, per particle vectors: global scalar, per particle vector:
"compute reduce"_compute_reduce.html: per particle/grid/surf vectors: global scalar/vector:
"fix ave/time"_fix_ave_time.html: global scalars/vectors: global scalar/vector/array, file:
"fix ave/grid"_fix_ave_grid.html: per grid vectors/arrays: per grid vector/array:
"fix ave/surf"_fix_ave_surf.html: per surf vectors/arrays: per surf vector/array:
:tb(s=:)

:line

4.5 Visualizing SPARTA snapshots :link(howto_5),h4

The "dump image"_dump_image.html command can be used to do on-the-fly
visualization as a simulation proceeds.  It works by creating a series
of JPG or PNG or PPM files on specified timesteps.  The images can
include particles, grid cell quantities, and/or surface element
quantities.  This is not a substitute for using an interactive
visualization package in post-processing mode, but on-the-fly
visualization can be useful for debugging or making a high-quality
image of a particular snapshot of the simulation.

The "dump"_dump.html command can be used to create snapshots of
particle, grid cell, or surface element data as a simulation runs.
These can be post-processed and read in to other visualization
packages.

TODO: describe post-processing tools and viz packages

SPARTA snapshots are created by the "dump"_dump.html command which can
create files in several formats.  The native SPARTA dump format is a
text file (see "dump atom" or "dump custom").

A Python-based toolkit distributed by our group can read native SPARTA
dump files, including custom dump files with additional columns of
user-specified atom information, and convert them to various formats
or pipe them into visualization software directly.  See the "Pizza.py
WWW site"_pizza for details.  Specifically, Pizza.py can convert
SPARTA dump files into PDB, XYZ, "Ensight"_ensight, and VTK formats.
Pizza.py can pipe SPARTA dump files directly into the Raster3d and
RasMol visualization programs.  Pizza.py has tools that do interactive
3d OpenGL visualization and one that creates SVG images of dump file
snapshots.

:link(pizza,http://www.sandia.gov/~sjplimp/pizza.html)
:link(vmd,http://www.ks.uiuc.edu/Research/vmd)
:link(ensight,http://www.ensight.com)

:line

4.6 Library interface to SPARTA :link(howto_6),h4

As described in "Section 2.3"_Section_start.html#start_3, SPARTA can
be built as a library, so that it can be called by another code, used
in a "coupled manner"_Section_howto.html#howto_7 with other codes, or
driven through a "Python interface"_Section_python.html.

All of these methodologies use a C-style interface to SPARTA that is
provided in the files src/library.cpp and src/library.h.  The
functions therein have a C-style argument list, but contain C++ code
you could write yourself in a C++ application that was invoking SPARTA
directly.  The C++ code in the functions illustrates how to invoke
internal SPARTA operations.  Note that SPARTA classes are defined
within a SPARTA namespace (SPARTA_NS) if you use them from another C++
application.

Library.cpp contains these 4 functions:

void sparta_open(int, char **, MPI_Comm, void **);
void sparta_close(void *);
void sparta_file(void *, char *);
char *sparta_command(void *, char *); :pre

The sparta_open() function is used to initialize SPARTA, passing in a
list of strings as if they were "command-line
arguments"_Section_start.html#start_5 when SPARTA is run in
stand-alone mode from the command line, and a MPI communicator for
SPARTA to run under.  It returns a ptr to the SPARTA object that is
created, and which is used in subsequent library calls.  The
sparta_open() function can be called multiple times, to create
multiple instances of SPARTA.

SPARTA will run on the set of processors in the communicator.  This
means the calling code can run SPARTA on all or a subset of
processors.  For example, a wrapper script might decide to alternate
between SPARTA and another code, allowing them both to run on all the
processors.  Or it might allocate half the processors to SPARTA and
half to the other code and run both codes simultaneously before
syncing them up periodically.  Or it might instantiate multiple
instances of SPARTA to perform different calculations.

The sparta_close() function is used to shut down an instance of SPARTA
and free all its memory.

The sparta_file() and sparta_command() functions are used to pass a
file or string to SPARTA as if it were an input script or single
command in an input script.  Thus the calling code can read or
generate a series of SPARTA commands one line at a time and pass it
thru the library interface to setup a problem and then run it,
interleaving the sparta_command() calls with other calls to extract
information from SPARTA, perform its own operations, or call another
code's library.

Other useful functions are also included in library.cpp. For example:

void *sparta_extract_global(void *, char *)
void *sparta_extract_compute(void *, char *, int, int)
void *sparta_extract_variable(void *, char *, char *) :pre

This can extract various global quantities from SPARTA as well as
values calculated by a compute or variable.  See the library.cpp file
and its associated header file library.h for details.

Other functions may be added to the library interface as needed to
allow reading from or writing to internal SPARTA data structures. 

The key idea of the library interface is that you can write any
functions you wish to define how your code talks to SPARTA and add
them to src/library.cpp and src/library.h, as well as to the "Python
interface"_Section_python.html.  The routines you add can in principle
access or change any SPARTA data you wish.  The examples/COUPLE and
python directories have example C++ and C and Python codes which show
how a driver code can link to SPARTA as a library, run SPARTA on a
subset of processors, grab data from SPARTA, change it, and put it
back into SPARTA.

:line

4.7 Coupling SPARTA to other codes :link(howto_7),h4

SPARTA is designed to allow it to be coupled to other codes.  For
example, a continuum finite element (FE) simulation might use SPARTA
grid cell quantities as boundary conditions on FE nodal points,
compute a FE solution, and return continuum flow conditions as
boundary conditions for SPARTA to use.

SPARTA can be coupled to other codes in at least 3 ways.  Each has
advantages and disadvantages, which you'll have to think about in the
context of your application.

(1) Define a new "fix"_fix.html command that calls the other code.  In
this scenario, SPARTA is the driver code.  During its timestepping,
the fix is invoked, and can make library calls to the other code,
which has been linked to SPARTA as a library.  See "Section
8"_Section_modify.html of the documentation for info on how to add a
new fix to SPARTA.

(2) Define a new SPARTA command that calls the other code.  This is
conceptually similar to method (1), but in this case SPARTA and the
other code are on a more equal footing.  Note that now the other code
is not called during the timestepping of a SPARTA run, but between
runs.  The SPARTA input script can be used to alternate SPARTA runs
with calls to the other code, invoked via the new command.  The
"run"_run.html command facilitates this with its {every} option, which
makes it easy to run a few steps, invoke the command, run a few steps,
invoke the command, etc.

In this scenario, the other code can be called as a library, as in
(1), or it could be a stand-alone code, invoked by a system() call
made by the command (assuming your parallel machine allows one or more
processors to start up another program).  In the latter case the
stand-alone code could communicate with SPARTA thru files that the
command writes and reads.

See "Section_modify"_Section_modify.html of the documentation for how
to add a new command to SPARTA.

(3) Use SPARTA as a library called by another code.  In this case the
other code is the driver and calls SPARTA as needed.  Or a wrapper
code could link and call both SPARTA and another code as libraries.
Again, the "run"_run.html command has options that allow it to be
invoked with minimal overhead (no setup or clean-up) if you wish to do
multiple short runs, driven by another program.

Examples of driver codes that call SPARTA as a library are included in
the examples/COUPLE directory of the SPARTA distribution; see
examples/COUPLE/README for more details:

"Section 2.3"_Section_start.html#start3 of the manual describes how to
build SPARTA as a library.  Once this is done, you can interface with
SPARTA either via C++, C, Fortran, or Python (or any other language
that supports a vanilla C-like interface).  For example, from C++ you
could create one (or more) "instances" of SPARTA, pass it an input
script to process, or execute individual commands, all by invoking the
correct class methods in SPARTA.  From C or Fortran you can make
function calls to do the same things.  See
"Section_9"_Section_python.html of the manual for a description of the
Python wrapper provided with SPARTA that operates through the SPARTA
library interface.

The files src/library.cpp and library.h contain the C-style interface
to SPARTA.  See "Section 4.6"_#howto_6 of the manual for a description
of the interface and how to extend it for your needs.

Note that the sparta_open() function that creates an instance of
SPARTA takes an MPI communicator as an argument.  This means that
instance of SPARTA will run on the set of processors in the
communicator.  Thus the calling code can run SPARTA on all or a subset
of processors.  For example, a wrapper script might decide to
alternate between SPARTA and another code, allowing them both to run
on all the processors.  Or it might allocate half the processors to
SPARTA and half to the other code and run both codes simultaneously
before syncing them up periodically.  Or it might instantiate multiple
instances of SPARTA to perform different calculations.

:line

4.8 Details of grid geometry in SPARTA :link(howto_8),h4

TODO: describe parent, child, unsplit, split, sub cells

describe cell IDs

:line

4.9 Details of surfaces in SPARTA :link(howto_9),h4

TODO: describe watertight rule, surf IDs

how you can have multiple objects in one simulation

how to assign different collision models to different surfs

how to clip surf to simulation box, what to watch out for

kinds of surfs that are illegal:
  infininitly thin, duplicate points, touching, etc
